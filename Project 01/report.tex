\documentclass[a4paper,11pt]{article}
\usepackage[latin1]{inputenc}
\usepackage[top=2cm, left = 2cm , right=2cm , bottom=2cm]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{subcaption}

%\usepackage[font=small,labelfont=bf]{caption}
%\usepackage[brazil]{babel}

\usepackage{algorithm}
%\usepackage{algorithmic}
\usepackage[noend]{algpseudocode}
\usepackage{hyperref}

\pagestyle{plain}

\begin{document}

\begin{center}
\textbf{Project 01}\\ \hspace{5pt}Prof. Diego de Freitas Aranha\\MO421
\end{center}

\begin{center}
Pedro Gabriel Calixto Mendon\c{c}a - RA 118363\\
\end{center}

% \tableofcontents

\section{Introduction}
\hspace{14pt}

The project 01 reports the method used for breaking a Two-Time Pad cipher.
The attack was done using two ciphertexts generated by two different plaintexts
using the same One-Time Pad (OTP) cipher. The original messages are written
in English.

The OTP is a stream cipher, in which the key has the same length of the message
being sent. The OTP performs a XOR operation with every bit of the message and
the key. If the sender does not repeat the same key for various messages and the
key is generated using random bits (such that a frequency analysis cannot be
performed as an attack), the perfect secrecy can be guaranteed.

As it will be seen, using the same OTP cipher for different messages is insecure
and can be broken using a technique called \textit{scrib dragging}.

\section{Method} \label{method}
\hspace{14pt}

When the OTP cipher is used on two different messages, a XOR operation between
the two ciphertexts equals a XOR between the two original messages.
Being $c_i$ the ciphertexts, $m_i$ the plaintexts $k$ the key and $\oplus$ the XOR
operation:
\begin{gather*}
	c_1 \oplus c_2 = (m_1 \oplus k) \oplus (m_2 \oplus k) \\
	c_1 \oplus c_2 = m_1 \oplus m_2
\end{gather*}
This can be achieved because the XOR operation is commutative and the XOR of
two equal variables equals 0 ($k \oplus k = 0$).

Using the property above, a technique called \textit{scrib dragging} can be used.
It consists in using a dictionary of possible words for the plaintexts, and XOR'ing it
against the XOR of $c_1$ and $c_2$, called $c_{xor}$ here. A word is guessed
(\textit{e.g.}, "the", the most common word in English), and if the XOR of the word
and the subsection of $c_XOR$ with the same length of the word returns a word that
is valid in the English language, the word used is probably a word in one of the
plaintexts. This can be seen below in the example.
\begin{gather*}
	m_1[1..3] = "the", m_2[1..3] = "and" \\ \\
	c_{xor}[1..3] \oplus "the" = (c_1[1..3] \oplus c_2[1..3]) \oplus "the" \\
	c_{xor}[1..3] \oplus "the" = (m_1[1..3] \oplus c_2[1..3]) \oplus "the" \\
	c_{xor}[1..3] \oplus "the" = ("the" \oplus "and") \oplus "the" \\
	c_{xor}[1..3] \oplus "the" = "and"
\end{gather*}

So, if the $c_{xor} \oplus word$ results in a possible English word, the next positions
of $c_{xor}$ can be tested against the dictionary of English words until the plaintexts
completion.

This is the general idea for \textit{crib dragging} and the pseudocode used is below.

\pagebreak

\begin{algorithm}
\caption{Pseudocode used for crib dragging using two ciphertexts}\label{cribdrag}
\begin{algorithmic}[1]
\Procedure{CribDrag}{cipherxor, cipherlen, dictionary, plain1, plain2, index1, index2}
\If {$ \text{length of } plain1 \leqslant cipherlen $}
	\Return plain1, plain2
\EndIf
\If {$ \text{last word in } plain1 \text{ is present in } dictionary $}
	\State $possibleWords \gets \text{words in dictionary starting with plain1 last word}$
\Else
	\State $possibleWords \gets dictionary$
\EndIf
\ForAll {$word \text{ in } possibleWords$}
	\State $word \gets word + \text{\lq}\text{ }\text{\rq}$
	\State $cribxor \gets (plain1 + \text{word}) \oplus cipherxor$
	\If {$cribxor \text{ is a valid text according to the dictionary}$}
		\State $newplain1, newplain2 = \Call{CribDrag}{cipherxor, cipherlen, dictionary,
			cribxor, plain1 + word, index2 + \text{ length of word}, index1 + \text{ length of word}}$
		\Comment Recursively calls CribDrag for the next cipherxor positions
		\If {$newplain1 \text{ is not empty and } newplain2 \text{ is not empty}$}
			\State \Return newplain1, newplain2
			\Comment If the CribDrag returned plaintexts are not empty, they are valid and returned
		\EndIf
	\EndIf
\EndFor
\State \Return empty, empty
\Comment If it reaches the end, the plaintexts could not be found
\EndProcedure
\end{algorithmic}
\end{algorithm}

\section{Conclusion}
\hspace{14pt}

The dictionary used is a list of the 10,000 most common English words in order of
frequency, as determined by n-gram frequency analysis of the Google's Trillion
Word Corpus, found on \href{https://github.com/first20hours/google-10000-english}{GitHub}.

The procedures and algorithm described in \ref{method} were used against the two
given ciphertexts, and the discovered original messages are:

\begin{verbatim}
I can't in good conscience allow the U.S. government ultimately simple conclusion:
the U.S. government had built a system that has as its with this massive surveillance
machine they're secretly buildi

Taken in its entirety, the Snowden archive led to an to destroy privacy, internet
freedom and basic liberties for people around the world goal the complete elimination
of electronic privacy worldwide.
\end{verbatim}

The first plaintext has an incomplete ending because its ciphertext had a length
greater than the other ciphertext, and the original message can only be found for
the same length of characters. Still, only 3 characters were not discovered, which
probably are "ng.". For the same reason, 201 bits of the key were discovered, for
it would need 205-bit ciphertexts length to discover the remaining key bits.

%\section{References}
%[1] Nussenzveig, H. Moyses, Curso de FiÂ­sica Basica - Volume 4: Optica e Fisica Moderna, Edgard Blucher, 4a Edicao; \\
%$\text{[2]}$ Halliday, David, Fundamentos de Fisica - Volume 4: Optica e Fisica Moderna, LTC, 8a Edicao;\\
\end{document}
